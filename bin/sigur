// Generated by CoffeeScript 1.10.0
(function() {
  var AsyncTranslator, _, asyncifyFile, falafel, fs, outputPath, sourcePath,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  falafel = require('falafel');

  fs = require('fs');

  _ = require('lodash');

  asyncifyFile = function(sourcePath, outputPath) {
    return fs.readFile(sourcePath, 'utf8', function(err, source) {
      var a;
      if (err) {
        console.log('ERROR', err);
        return;
      }
      a = new AsyncTranslator().translate(source);
      a = String(a).replace(/\n+/g, '\n').replace('}', '}\n');
      return fs.writeFile(outputPath, a);
    });
  };

  AsyncTranslator = (function() {
    function AsyncTranslator() {
      this.rewriteWaterfall = bind(this.rewriteWaterfall, this);
      this.rewriteBlock = bind(this.rewriteBlock, this);
      this._isCallbackName = bind(this._isCallbackName, this);
      this._isCallback = bind(this._isCallback, this);
      this._isCallToArgCallback = bind(this._isCallToArgCallback, this);
      this._isParallelCallback = bind(this._isParallelCallback, this);
      this._isMongoose = bind(this._isMongoose, this);
      this.rewriteFunction = bind(this.rewriteFunction, this);
      this.indexSignatures = bind(this.indexSignatures, this);
      this.translate = bind(this.translate, this);
      this.indentSize = 2;
      this.args = [];
    }

    AsyncTranslator.prototype.translate = function(source) {
      this.signatureIndex = this.indexSignatures(source);
      return falafel(source, (function(_this) {
        return function(node) {
          if (node.type === 'FunctionDeclaration') {
            return node.update(_this.rewriteFunction(node));
          } else if (node.parent && node.parent.type === 'Program') {
            return node.update(_this.rewriteBlock([node]).code);
          }
        };
      })(this));
    };

    AsyncTranslator.prototype._source = function(e) {
      return e.source();
    };

    AsyncTranslator.prototype._indent = function(depth) {
      return _.repeat(' ', this.indentSize * depth);
    };

    AsyncTranslator.prototype.indexSignatures = function(source) {
      var index;
      index = {};
      falafel(source, function(node) {
        if (node.type === 'FunctionDeclaration') {
          return index[node.id.name] = _.map(node.params, 'name');
        }
      });
      return index;
    };

    AsyncTranslator.prototype.rewriteFunction = function(node) {
      var argCode, asyncStatus, blockResult, header, params;
      this.args.push(_.map(node.params, 'name'));
      blockResult = this.rewriteBlock(node.body.body, 1);
      this.args.pop;
      if (blockResult.isAsync) {
        asyncStatus = 'async ';
        params = node.params.slice(0, -1);
      } else {
        asyncStatus = '';
        params = node.params;
        console.log(blockResult);
      }
      argCode = _.map(params, this._source).join(', ');
      header = asyncStatus + "function " + node.id.name + "(" + argCode + ") {";
      return header + "\n" + blockResult.code + "}\n";
    };

    AsyncTranslator.prototype._isMongoose = function(node) {
      return node.type === 'MemberExpression' && node.property.type === 'Identifier' && node.property.name === 'exec';
    };

    AsyncTranslator.prototype._isParallelCallback = function(node) {
      return node && node.type === 'Identifier' && node.name === this.parallelCallback;
    };

    AsyncTranslator.prototype._isCallToArgCallback = function(node) {
      return node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === _.last(_.last(this.args));
    };

    AsyncTranslator.prototype._isCallback = function(node) {
      return node && (node.type === 'FunctionExpression' || node.type === 'Identifier' && this._isCallbackName(node.name));
    };

    AsyncTranslator.prototype._isCallbackName = function(name) {
      return name.match(/[Cc](all)?[Bb](ack)?/) !== null;
    };

    AsyncTranslator.prototype._simplifyExpressions = function(nodes) {
      return _.map(nodes, function(node) {
        if (node.type === 'ExpressionStatement') {
          return node.expression;
        } else {
          return node;
        }
      });
    };

    AsyncTranslator.prototype.rewriteBlock = function(nodes, depth) {
      var a, afterCode, argCode, block, blockCode, callee, i, ind, iterator, lastArg, len, node, result, results, sequence;
      result = {
        isAsync: false,
        code: ''
      };
      results = [];
      ind = this._indent(depth);
      nodes = this._simplifyExpressions(nodes);
      for (i = 0, len = nodes.length; i < len; i++) {
        node = nodes[i];
        console.log(ind + 'node', node.source());
        lastArg = _.last(node["arguments"]);
        if (node.type === 'CallExpression' && node.callee.type === 'MemberExpression' && node.callee.object.name === 'async' && node.callee.property.name === 'each') {
          block = node["arguments"][1];
          this.parallelCallback = block.params[1].name;
          blockCode = "\n" + this.rewriteBlock(block.body.body, depth + 1).code;
          afterCode = "\n" + this.rewriteBlock(lastArg.body.body, depth).code;
          sequence = node["arguments"][0].name;
          iterator = node["arguments"][1].params[0].name;
          result.isAsync = true;
          results.push(ind + "await " + sequence + ".parallelEach(" + iterator + " => {" + blockCode + ind + "});" + afterCode);
        } else if (node.type === 'CallExpression' && node.callee.type === 'MemberExpression' && node.callee.object.name === 'async' && node.callee.property.name === 'waterfall') {
          results.push(this.rewriteWaterfall(node["arguments"][0].elements, depth));
        } else if (node.type === 'CallExpression' && this._isParallelCallback(lastArg)) {
          argCode = _.map(node["arguments"].slice(0, -1), this._source).join('\n');
          results.push("" + ind + (node.callee.source()) + "(" + argCode + ");");
        } else if (node.type === 'CallExpression' && node.type === 'Identifier' && node.callee.name === this.parallelCallback) {
          2;
        } else if (node.type === 'CallExpression' && this._isCallback(lastArg)) {
          if (lastArg.type !== 'FunctionExpression') {
            a = "" + ind;
          } else {
            a = ind + "var " + (_.last(lastArg.params).name) + " = ";
          }
          if (this._isMongoose(node.callee)) {
            callee = node.callee.object;
            argCode = '';
          } else {
            callee = node.callee;
            argCode = '(' + _.map(node["arguments"].slice(0, -1), this._source).join(', ') + ')';
          }
          results.push(a + "await " + (callee.source()) + argCode + ";");
          results.push(this.rewriteBlock(_.last(node["arguments"]).body.body, depth).code);
          result.isAsync = true;
        } else if (this._isCallToArgCallback(node)) {
          results.push(ind + "return" + (lastArg ? ' ' + lastArg.source() : '') + ";");
          result.isAsync = true;
        } else {
          results.push("" + ind + (node.source()) + ";\n");
        }
      }
      result.code = results.join('\n') + '\n';
      return result;
    };

    AsyncTranslator.prototype.rewriteWaterfall = function(calls, depth) {
      var f, ind, rewrites;
      rewrites = [];
      ind = this._indent(depth);
      _.each(_.zip(calls.slice(0, -1), calls.slice(1)), (function(_this) {
        return function(arg, j) {
          var call, f, nextCall;
          call = arg[0], nextCall = arg[1];
          f = j === 0 ? '' : _this.signatureIndex[call.name][0];
          console.log('F', f, j, call.name, _this.signatureIndex);
          return rewrites.push(ind + "var " + _this.signatureIndex[nextCall.name][0] + " = await " + (call.source()) + "(" + f + ");");
        };
      })(this));
      f = this.signatureIndex[_.last(calls).name][0];
      rewrites.push(ind + "await " + (_.last(calls).source()) + "(" + f + ");");
      return rewrites.join('\n') + '\n';
    };

    return AsyncTranslator;

  })();

  sourcePath = process.argv[2];

  outputPath = sourcePath.replace(/\.js$/, '.es7');

  asyncifyFile(sourcePath, outputPath);

}).call(this);
