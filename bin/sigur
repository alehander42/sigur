// Generated by CoffeeScript 1.10.0
(function() {
  var AsyncTranslator, _, asyncifyFile, escodegen, falafel, fs, outputPath, sourcePath,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  falafel = require('falafel');

  fs = require('fs');

  escodegen = require('escodegen');

  _ = require('lodash');

  asyncifyFile = function(sourcePath, outputPath) {
    return fs.readFile(sourcePath, 'utf8', function(err, source) {
      var a;
      if (err) {
        console.log('ERROR', err);
        return;
      }
      a = new AsyncTranslator().translate(source);
      a = String(a).replace(/\n+/g, '\n').replace('}', '}\n');
      return fs.writeFile(outputPath, a);
    });
  };

  AsyncTranslator = (function() {
    function AsyncTranslator() {
      this.rewriteSeries = bind(this.rewriteSeries, this);
      this._refactorSerie = bind(this._refactorSerie, this);
      this.rewriteWaterfall = bind(this.rewriteWaterfall, this);
      this._rewriteWaterfallCall = bind(this._rewriteWaterfallCall, this);
      this._rewriteLine = bind(this._rewriteLine, this);
      this.rewriteBlock = bind(this.rewriteBlock, this);
      this._isCallbackName = bind(this._isCallbackName, this);
      this._isCallback = bind(this._isCallback, this);
      this._isCallToArgCallback = bind(this._isCallToArgCallback, this);
      this._isParallelCallback = bind(this._isParallelCallback, this);
      this._isMongoose = bind(this._isMongoose, this);
      this.rewriteFunction = bind(this.rewriteFunction, this);
      this.indexSignatures = bind(this.indexSignatures, this);
      this.translate = bind(this.translate, this);
      this.indentSize = 2;
      this.args = [];
      this.anonn = 0;
      this.asyncs = [];
    }

    AsyncTranslator.prototype.translate = function(source) {
      this.signatureIndex = this.indexSignatures(source);
      return falafel(source, (function(_this) {
        return function(node) {
          if (node.type === 'FunctionDeclaration') {
            return node.update(_this.rewriteFunction(node));
          } else if (node.parent && node.parent.type === 'Program') {
            return node.update('\n' + _.map(_this.rewriteBlock([node]), _this.esGenerate).join('\n'));
          }
        };
      })(this));
    };

    AsyncTranslator.prototype.esGenerate = function(node) {
      return escodegen.generate(node, {
        format: {
          indent: {
            style: '  '
          }
        },
        comment: true
      });
    };

    AsyncTranslator.prototype._source = function(e) {
      return e.source();
    };

    AsyncTranslator.prototype._indent = function(depth) {
      return _.repeat(' ', this.indentSize * depth);
    };

    AsyncTranslator.prototype.indexSignatures = function(source) {
      var index;
      index = {};
      falafel(source, function(node) {
        if (node.type === 'FunctionDeclaration') {
          return index[node.id.name] = _.map(node.params, 'name');
        }
      });
      return index;
    };

    AsyncTranslator.prototype.rewriteFunction = function(node) {
      var blockResult;
      this.args.push(_.map(node.params, 'name'));
      this.asyncs.push(false);
      blockResult = this.rewriteBlock(node.body.body, 1);
      node.async = this.asyncs.pop;
      this.args.pop;
      node.params = node.params.slice(0, -1);
      blockResult = this._cleanReturns(blockResult);
      node.body = {
        type: 'BlockStatement',
        body: blockResult
      };
      return this.esGenerate(node);
    };

    AsyncTranslator.prototype._isMongoose = function(node) {
      return node.type === 'MemberExpression' && node.property.type === 'Identifier' && node.property.name === 'exec';
    };

    AsyncTranslator.prototype._cleanReturns = function(block) {
      var a, last;
      if (block.length === 0) {
        return [];
      } else if (block.length === 1) {
        if (block[0].type === 'ReturnStatement' && block[0].argument === null) {
          return [];
        } else {
          return block;
        }
      } else {
        a = block[block.length - 2];
        last = block[block.length - 1];
        if (last.type === 'ReturnStatement' && last.argument && last.argument.type === 'Identifier' && a.type === 'VariableDeclaration' && a.declarations[0].id.type === 'Identifier' && a.declarations[0].id.name === last.argument.name) {
          return block.slice(0, -2).concat({
            type: 'ReturnStatement',
            argument: a.declarations[0].init
          });
        } else if (last.type === 'ReturnStatement' && last.argument === null) {
          return block.slice(0, -1);
        } else {
          return block;
        }
      }
    };

    AsyncTranslator.prototype._isParallelCallback = function(node) {
      return node && node.type === 'Identifier' && node.name === this.parallelCallback;
    };

    AsyncTranslator.prototype._isCallToArgCallback = function(node) {
      return node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === _.last(_.last(this.args));
    };

    AsyncTranslator.prototype._isCallback = function(node) {
      return node && (node.type === 'FunctionExpression' || node.type === 'Identifier' && this._isCallbackName(node.name));
    };

    AsyncTranslator.prototype._isCallbackName = function(name) {
      return name.match(/[Cc](all)?[Bb](ack)?/) !== null;
    };

    AsyncTranslator.prototype._simplifyExpressions = function(nodes) {
      return _.map(nodes, function(node) {
        if (node.type === 'ExpressionStatement') {
          return node.expression;
        } else {
          return node;
        }
      });
    };

    AsyncTranslator.prototype.rewriteBlock = function(nodes, depth) {
      var ind, result, results;
      result = {
        isAsync: false,
        code: ''
      };
      results = [];
      ind = this._indent(depth);
      return _.reduce(nodes, ((function(_this) {
        return function(results, node) {
          return results.concat(_this._rewriteLine(node, depth));
        };
      })(this)), []);
    };

    AsyncTranslator.prototype._ensureExpression = function(t) {
      if (t.type === 'ExpressionStatement' || !_.contains(t.type, 'Expression')) {
        return t;
      } else {
        return {
          type: 'ExpressionStatement',
          expression: t
        };
      }
    };

    AsyncTranslator.prototype._isAsyncMethodCall = function(node, method) {
      return node.callee.type === 'MemberExpression' && node.callee.object.name === 'async' && node.callee.property.name === method;
    };

    AsyncTranslator.prototype._rewriteLine = function(node, depth) {
      var afterCode, await, block, expression, iterator, lastArg, s, sequence;
      if (node.type === 'CallExpression') {
        lastArg = _.last(node["arguments"]);
      }
      switch (false) {
        case node.type !== 'ExpressionStatement':
          s = this._rewriteLine(node.expression);
          if (!Array.isArray(s)) {
            s = [s];
          }
          return _.map(s, this._ensureExpression);
        case node.type !== 'BlockStatement':
          return {
            type: 'BlockStatement',
            body: _.map(node.body, function(l) {
              return this._rewriteLine(this._rewriteLine, depth);
            })
          };
        case !(node.type === 'Identifier' && node.callee.name === this.parallelCallback):
          return [];
        case node.type === 'CallExpression':
          return node;
        case !this._isAsyncMethodCall(node, 'each'):
          block = node["arguments"][1];
          this.parallelCallback = block.params[1].name;
          block.body.body = this.rewriteBlock(block.body.body, depth + 1);
          if (lastArg.type === 'FunctionExpression') {
            afterCode = this.rewriteBlock(lastArg.body.body, depth);
          } else if (lastArg.type === 'Identifier' && lastArg.name === _.last(_.last(this.args))) {
            afterCode = [
              {
                type: 'ReturnStatement',
                argument: null
              }
            ];
          } else {
            afterCode = [this._rewriteLine(lastArg)];
          }
          sequence = node["arguments"][0].name;
          iterator = node["arguments"][1].params[0].name;
          this.asyncs[this.asyncs.length - 1] = true;
          return [
            {
              type: 'AwaitExpression',
              argument: {
                type: 'CallExpression',
                callee: {
                  type: 'MemberExpression',
                  object: {
                    type: 'Identifier',
                    name: sequence
                  },
                  property: {
                    type: 'Identifier',
                    name: 'parallelEach'
                  }
                },
                "arguments": [
                  {
                    type: 'ArrowFunctionExpression',
                    id: null,
                    body: block.body,
                    params: [
                      {
                        type: 'Identifier',
                        name: iterator
                      }
                    ]
                  }
                ]
              }
            }
          ].concat(afterCode);
        case !this._isAsyncMethodCall(node, 'waterfall'):
          return this.rewriteWaterfall(node["arguments"][0].elements, node["arguments"][1], depth);
        case !this._isAsyncMethodCall(node, 'series'):
          return this.rewriteSeries(node["arguments"][0].elements, node["arguments"][1], depth);
        case !this._isParallelCallback(lastArg):
          node["arguments"] = node["arguments"].slice(0, -1);
          return node;
        case !this._isCallback(lastArg):
          if (this._isMongoose(node.callee)) {
            node = node.callee.object;
            node["arguments"] = [];
          } else {
            node["arguments"] = node["arguments"].slice(0, -1);
          }
          this.asyncs[this.asyncs.length - 1] = true;
          await = {
            type: 'AwaitExpression',
            argument: node
          };
          expression = lastArg.type !== 'FunctionExpression' ? await : this._variableAssignment(_.last(lastArg.params).name, await);
          return [expression].concat(this.rewriteBlock(lastArg.body.body, depth));
        case !this._isCallToArgCallback(node):
          this.asyncs[this.asyncs.length - 1] = true;
          return {
            type: 'ReturnStatement',
            argument: lastArg ? lastArg : null
          };
        default:
          return node;
      }
    };

    AsyncTranslator.prototype._variableAssignment = function(name, init) {
      return {
        type: 'VariableDeclaration',
        kind: 'let',
        declarations: [
          {
            type: 'VariableDeclarator',
            id: {
              type: 'Identifier',
              name: name
            },
            init: init
          }
        ]
      };
    };

    AsyncTranslator.prototype._rewriteWaterfallCall = function(call) {
      if (call.type === 'Identifier') {
        return {
          name: call.name,
          source: {
            type: 'CallExpression',
            callee: call,
            "arguments": []
          }
        };
      } else if (call.type === 'CallExpression' && call.callee.type === 'MemberExpression' && call.callee.object.type === 'Identifier' && call.callee.object.name === 'async' && call.callee.property.name === 'apply') {
        call.callee = call["arguments"][0];
        call["arguments"] = call["arguments"].slice(1);
        return {
          name: call["arguments"][0].name,
          source: call
        };
      } else if (call.type === 'FunctionExpression') {
        this.signatureIndex[String(this.anonn)] = _.map(call.params, 'name');
        this.anonn += 1;
        return {
          name: String(this.anonn - 1),
          source: {
            type: 'CallExpression',
            callee: call,
            "arguments": []
          }
        };
      } else {
        throw "2789";
      }
    };

    AsyncTranslator.prototype.rewriteWaterfall = function(calls, callback, depth) {
      var call, f, ind, rewrites, test;
      rewrites = [];
      ind = this._indent(depth);
      calls = _.map(calls, this._rewriteWaterfallCall);
      _.each(_.zip(calls.slice(0, -1), calls.slice(1)), (function(_this) {
        return function(arg, j) {
          var call, f, nextCall;
          call = arg[0], nextCall = arg[1];
          f = j === 0 ? [] : {
            type: 'Identifier',
            name: _this.signatureIndex[call.name][0]
          };
          call.source["arguments"] = call.source["arguments"].concat(f);
          return rewrites.push(_this._variableAssignment(_this.signatureIndex[nextCall.name][0]), {
            type: 'AwaitExpression',
            argument: call.source
          });
        };
      })(this));
      call = _.last(calls);
      f = {
        type: 'Identifier',
        name: this.signatureIndex[call.name][0]
      };
      call.source["arguments"] = call.source["arguments"].concat(f);
      rewrites.push({
        type: 'AwaitExpression',
        argument: call.source
      });
      if (callback && callback.type === 'FunctionExpression' && callback.body.body.length === 1 && callback.body.body[0].type === 'IfStatement') {
        test = callback.body.body[0].test;
        if (test.type === 'Identifier' && test.name === callback.params[0].name) {
          return {
            type: 'TryStatement',
            block: {
              type: 'BlockStatement',
              body: rewrites
            },
            handler: {
              type: 'CatchClause',
              param: {
                type: 'Identifier',
                name: callback.params[0].name
              },
              body: callback.body.body[0].consequent
            },
            finalizer: null
          };
        } else {
          return rewrites;
        }
      } else {
        return rewrites;
      }
    };

    AsyncTranslator.prototype._refactorSerie = function(func) {
      var body;
      this.args.push(_.map(func.params, 'name'));
      body = this._cleanReturns(this.rewriteBlock(func.body.body, 0));
      this.args.pop;
      if (body.length === 1 && body[0].type === 'ReturnStatement') {
        return body[0].argument;
      } else {
        func.body.body = body;
        func.params = [];
        return {
          type: 'AwaitExpression',
          argument: {
            type: 'CallExpression',
            callee: func,
            "arguments": []
          }
        };
      }
    };

    AsyncTranslator.prototype.rewriteSeries = function(functions, endCallback) {
      var assignment, body, list, refactored;
      refactored = _.map(functions, this._refactorSerie);
      if (endCallback) {
        list = {
          type: 'ArrayExpression',
          elements: refactored
        };
        assignment = this._variableAssignment(endCallback.params[1].name, list);
        body = this.rewriteBlock(endCallback.body.body, 0);
        return [assignment].concat(body);
      } else {
        return refactored;
      }
    };

    return AsyncTranslator;

  })();

  sourcePath = process.argv[2];

  outputPath = sourcePath.replace(/\.js$/, '.es7');

  asyncifyFile(sourcePath, outputPath);

}).call(this);
