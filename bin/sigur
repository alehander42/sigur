// Generated by CoffeeScript 1.10.0
(function() {
  var AsyncTranslator, _, asyncifyFile, escodegen, falafel, fs, outputPath, sourcePath,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  falafel = require('falafel');

  fs = require('fs');

  escodegen = require('escodegen');

  _ = require('lodash');

  asyncifyFile = function(sourcePath, outputPath) {
    return fs.readFile(sourcePath, 'utf8', function(err, source) {
      var a;
      if (err) {
        console.log('ERROR', err);
        return;
      }
      a = new AsyncTranslator().translate(source);
      a = String(a).replace(/\n+/g, '\n').replace('}', '}\n');
      return fs.writeFile(outputPath, a);
    });
  };

  AsyncTranslator = (function() {
    function AsyncTranslator() {
      this.rewriteSeries = bind(this.rewriteSeries, this);
      this._refactorSerie = bind(this._refactorSerie, this);
      this.rewriteWaterfall = bind(this.rewriteWaterfall, this);
      this._rewriteWaterfallCall = bind(this._rewriteWaterfallCall, this);
      this._variableAssignment = bind(this._variableAssignment, this);
      this._rewriteLine = bind(this._rewriteLine, this);
      this.rewriteBlock = bind(this.rewriteBlock, this);
      this._isCallbackName = bind(this._isCallbackName, this);
      this._isCallback = bind(this._isCallback, this);
      this._isCallToArgCallback = bind(this._isCallToArgCallback, this);
      this._isParallelCallback = bind(this._isParallelCallback, this);
      this._applyPattern = bind(this._applyPattern, this);
      this._detectErrorPattern = bind(this._detectErrorPattern, this);
      this._isMongoose = bind(this._isMongoose, this);
      this.rewriteFunction = bind(this.rewriteFunction, this);
      this.indexSignatures = bind(this.indexSignatures, this);
      this.translate = bind(this.translate, this);
      this.indentSize = 2;
      this.args = [];
      this.anonn = 0;
      this.asyncs = [];
      this.names = [];
      this.errorPattern = null;
      this.errorCount = 0;
    }

    AsyncTranslator.prototype.translate = function(source) {
      this.signatureIndex = this.indexSignatures(source);
      return falafel(source, (function(_this) {
        return function(node) {
          if (node.type === 'FunctionDeclaration') {
            return node.update(_this.rewriteFunction(node));
          } else if (node.parent && node.parent.type === 'Program') {
            return node.update('\n' + _.map(_this.rewriteBlock([node]), _this.esGenerate).join('\n'));
          }
        };
      })(this));
    };

    AsyncTranslator.prototype.esGenerate = function(node) {
      return escodegen.generate(node, {
        format: {
          indent: {
            style: '  '
          }
        },
        comment: true
      });
    };

    AsyncTranslator.prototype._source = function(e) {
      return e.source();
    };

    AsyncTranslator.prototype._indent = function(depth) {
      return _.repeat(' ', this.indentSize * depth);
    };

    AsyncTranslator.prototype.indexSignatures = function(source) {
      var index;
      index = {};
      falafel(source, function(node) {
        if (node.type === 'FunctionDeclaration') {
          return index[node.id.name] = _.map(node.params, 'name');
        }
      });
      return index;
    };

    AsyncTranslator.prototype.rewriteFunction = function(node) {
      var blockResult;
      this.args.push(_.map(node.params, 'name'));
      this.asyncs.push(false);
      this.names.push({});
      if (node.id) {
        this._detectErrorPattern(node);
      }
      blockResult = this.rewriteBlock(node.body.body, 1);
      node.async = this.asyncs.pop;
      this.args.pop;
      this.names.pop;
      node.params = node.params.slice(0, -1);
      blockResult = this._cleanReturns(blockResult);
      node.body = {
        type: 'BlockStatement',
        body: blockResult
      };
      if (this.errorCount > 0) {
        node.body = {
          type: 'BlockStatement',
          body: [
            {
              type: 'TryStatement',
              block: node.body,
              handler: {
                type: 'CatchClause',
                param: {
                  type: 'Identifier',
                  name: 'err'
                },
                body: {
                  type: 'BlockStatement',
                  body: [this.errorPattern]
                }
              },
              finalizer: null
            }
          ]
        };
      }
      return this.esGenerate(node);
    };

    AsyncTranslator.prototype._isMongoose = function(node) {
      return node.type === 'MemberExpression' && node.property.type === 'Identifier' && node.property.name === 'exec';
    };

    AsyncTranslator.prototype._detectErrorPattern = function(node) {
      return falafel(node.source(), (function(_this) {
        return function(n) {
          var errorPattern, o, r;
          if (n.type === 'IfStatement' && n.test.type === 'Identifier' && n.test.name === 'err' && n.consequent.body.length === 1) {
            if (n.consequent.body[0].type === 'ReturnStatement' && (n.consequent.body[0].argument.type === 'CallExpression' || n.consequent.body[0].argument.type === 'Identifier')) {
              o = n.consequent.body[0].argument;
              r = true;
            } else {
              o = n.consequent.body[0];
              r = false;
            }
            if (o.type === 'CallExpression' && o.callee.type === 'Identifier' && o["arguments"].length === 1 && o["arguments"][0].type === 'Identifier' && o["arguments"][0].name === 'err') {
              errorPattern = o;
              errorPattern.matches = function(e) {
                return e.type === 'CallExpression' && e.callee.type === 'Identifier' && e.callee.name === o.callee.name && e["arguments"].length === 1;
              };
              errorPattern.errorSigur = function(e) {
                return e["arguments"][0];
              };
            } else if (o.type === 'Identifier' && o.name === 'err') {
              errorPattern = o;
              errorPattern.matches = function(e) {
                return true;
              };
              errorPattern.errorSigur = function(e) {
                return e;
              };
            } else {
              _this.errorPattern = null;
              return;
            }
            if (r) {
              _this.errorPattern = {
                type: 'ReturnStatement',
                argument: o
              };
              _this.errorPattern.matches = function(e) {
                return e.type === 'ReturnStatement' && errorPattern.matches(e.argument);
              };
              return _this.errorPattern.errorSigur = function(e) {
                return errorPattern.errorSigur(e.argument);
              };
            } else {
              return _this.errorPattern = errorPattern;
            }
          }
        };
      })(this));
    };

    AsyncTranslator.prototype._applyPattern = function(expression) {
      return [
        {
          type: 'ThrowStatement',
          argument: expression
        }
      ];
    };

    AsyncTranslator.prototype._cleanReturns = function(block) {
      var a, last;
      if (block.length === 0) {
        return [];
      } else if (block.length === 1) {
        if (block[0].type === 'ReturnStatement' && block[0].argument === null) {
          return [];
        } else {
          return block;
        }
      } else {
        a = block[block.length - 2];
        last = block[block.length - 1];
        if (last.type === 'ReturnStatement' && last.argument && last.argument.type === 'Identifier' && a.type === 'VariableDeclaration' && a.declarations[0].id.type === 'Identifier' && a.declarations[0].id.name === last.argument.name) {
          return block.slice(0, -2).concat({
            type: 'ReturnStatement',
            argument: a.declarations[0].init
          });
        } else if (last.type === 'ReturnStatement' && last.argument === null) {
          return block.slice(0, -1);
        } else {
          return block;
        }
      }
    };

    AsyncTranslator.prototype._isParallelCallback = function(node) {
      return node && node.type === 'Identifier' && node.name === this.parallelCallback;
    };

    AsyncTranslator.prototype._isCallToArgCallback = function(node) {
      return node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === _.last(_.last(this.args));
    };

    AsyncTranslator.prototype._isCallback = function(node) {
      return node && (node.type === 'FunctionExpression' || node.type === 'Identifier' && this._isCallbackName(node.name));
    };

    AsyncTranslator.prototype._isCallbackName = function(name) {
      return name.match(/[Cc](all)?[Bb](ack)?/) !== null;
    };

    AsyncTranslator.prototype._simplifyExpressions = function(nodes) {
      return _.map(nodes, function(node) {
        if (node.type === 'ExpressionStatement') {
          return node.expression;
        } else {
          return node;
        }
      });
    };

    AsyncTranslator.prototype.rewriteBlock = function(nodes, depth) {
      var ind, result, results;
      result = {
        isAsync: false,
        code: ''
      };
      results = [];
      ind = this._indent(depth);
      return _.reduce(nodes, ((function(_this) {
        return function(results, node) {
          return results.concat(_this._rewriteLine(node, depth));
        };
      })(this)), []);
    };

    AsyncTranslator.prototype._ensureExpression = function(t) {
      if (t.type === 'ExpressionStatement' || !_.contains(t.type, 'Expression')) {
        return t;
      } else {
        return {
          type: 'ExpressionStatement',
          expression: t
        };
      }
    };

    AsyncTranslator.prototype._isAsyncMethodCall = function(node, method) {
      return node.callee.type === 'MemberExpression' && node.callee.object.name === 'async' && node.callee.property.name === method;
    };

    AsyncTranslator.prototype._matchesErrorPattern = function(node) {
      return this.errorPattern.matches(node);
    };

    AsyncTranslator.prototype._rewriteLine = function(node, depth) {
      var afterCode, alt, await, block, expression, iterator, lastArg, s, sequence;
      if (node.type === 'ReturnStatement') {
        console.log('s');
      }
      if (this.errorPattern !== null && this._matchesErrorPattern(node)) {
        this.errorCount += 1;
        return this._applyPattern(this.errorPattern.errorSigur(node));
      } else if (node.type === 'IfStatement' && node.test.type === 'Identifier' && this.errorPattern !== null && this._matchesErrorPattern(node.consequent.body[0]) && this.errorPattern.errorSigur(node.consequent.body[0]).type === 'Identifier' && this.errorPattern.errorSigur(node.consequent.body[0]).name === node.test.name) {
        this.errorCount += 1;
        return [];
      }
      if (node.type === 'CallExpression') {
        lastArg = _.last(node["arguments"]);
      }
      switch (false) {
        case node.type !== 'ExpressionStatement':
          s = this._rewriteLine(node.expression);
          if (!Array.isArray(s)) {
            s = [s];
          }
          return _.map(s, this._ensureExpression);
        case node.type !== 'BlockStatement':
          return {
            type: 'BlockStatement',
            body: _.reduce(node.body, (function(_this) {
              return function(a, l) {
                return a.concat(_this._rewriteLine(l, depth));
              };
            })(this), [])
          };
        case !(node.type === 'Identifier' && node.callee.name === this.parallelCallback):
          return [];
        case node.type === 'CallExpression':
          if (node.type === 'IfStatement') {
            node.consequent.body = this.rewriteBlock(node.consequent.body, depth + 1);
            if (node.alternate) {
              alt = this._rewriteLine(node.alternate, depth);
              if (Array.isArray(alt)) {
                alt = alt[0];
              }
              node.alternate = alt;
            }
            return node;
          } else {
            return node;
          }
          break;
        case !this._isAsyncMethodCall(node, 'each'):
          block = node["arguments"][1];
          this.parallelCallback = block.params[1].name;
          block.body.body = this.rewriteBlock(block.body.body, depth + 1);
          if (lastArg.type === 'FunctionExpression') {
            afterCode = this.rewriteBlock(lastArg.body.body, depth);
          } else if (lastArg.type === 'Identifier' && lastArg.name === _.last(_.last(this.args))) {
            afterCode = [
              {
                type: 'ReturnStatement',
                argument: null
              }
            ];
          } else {
            afterCode = [this._rewriteLine(lastArg)];
          }
          sequence = node["arguments"][0].name;
          iterator = node["arguments"][1].params[0].name;
          this.asyncs[this.asyncs.length - 1] = true;
          return [
            {
              type: 'AwaitExpression',
              argument: {
                type: 'CallExpression',
                callee: {
                  type: 'MemberExpression',
                  object: {
                    type: 'Identifier',
                    name: sequence
                  },
                  property: {
                    type: 'Identifier',
                    name: 'parallelEach'
                  }
                },
                "arguments": [
                  {
                    type: 'ArrowFunctionExpression',
                    id: null,
                    body: block.body,
                    params: [
                      {
                        type: 'Identifier',
                        name: iterator
                      }
                    ]
                  }
                ]
              }
            }
          ].concat(afterCode);
        case !this._isAsyncMethodCall(node, 'waterfall'):
          return this.rewriteWaterfall(node["arguments"][0].elements, node["arguments"][1], depth);
        case !this._isAsyncMethodCall(node, 'series'):
          return this.rewriteSeries(node["arguments"][0].elements, node["arguments"][1], depth);
        case !this._isParallelCallback(lastArg):
          node["arguments"] = node["arguments"].slice(0, -1);
          return node;
        case !this._isCallback(lastArg):
          if (this._isMongoose(node.callee)) {
            node = node.callee.object;
            node["arguments"] = [];
          } else {
            node["arguments"] = node["arguments"].slice(0, -1);
          }
          this.asyncs[this.asyncs.length - 1] = true;
          await = {
            type: 'AwaitExpression',
            argument: node
          };
          expression = lastArg.type !== 'FunctionExpression' ? [await] : this._variableAssignment(_.map(lastArg.params.slice(1), 'name'), await);
          return expression.concat(this.rewriteBlock(lastArg.body.body, depth));
        case !this._isCallToArgCallback(node):
          this.asyncs[this.asyncs.length - 1] = true;
          return {
            type: 'ReturnStatement',
            argument: lastArg ? lastArg : null
          };
        default:
          return node;
      }
    };

    AsyncTranslator.prototype._variableAssignment = function(names, init) {
      var fNames, i, len, name, u, undeclared;
      fNames = _.last(this.names);
      if (names.length === 1) {
        if (fNames[names[0]] !== void 0) {
          return [
            {
              type: 'AssignmentExpression',
              operator: '=',
              left: {
                type: 'Identifier',
                name: names[0]
              },
              right: init
            }
          ];
        } else {
          fNames[names[0]] = true;
          return [
            {
              type: 'VariableDeclaration',
              kind: 'var',
              declarations: [
                {
                  type: 'VariableDeclarator',
                  id: {
                    type: 'Identifier',
                    name: names[0]
                  },
                  init: init
                }
              ]
            }
          ];
        }
      } else {
        undeclared = _.select(names, function(name) {
          return fNames[name] === void 0;
        });
        for (i = 0, len = undeclared.length; i < len; i++) {
          name = undeclared[i];
          fNames[name] = true;
        }
        u = [];
        if (undeclared.length > 0) {
          u = [
            {
              type: 'VariableDeclaration',
              kind: 'var',
              declarations: _.map(undeclared, function(name) {
                return {
                  type: 'VariableDeclarator',
                  id: {
                    type: 'Identifier',
                    name: name
                  },
                  init: null
                };
              })
            }
          ];
        }
        u.push({
          type: 'AssignmentExpression',
          operator: '=',
          left: {
            type: 'Identifier',
            name: "[" + (names.join(', ')) + "]"
          },
          right: init
        });
        return u;
      }
    };

    AsyncTranslator.prototype._rewriteWaterfallCall = function(call) {
      if (call.type === 'Identifier') {
        return {
          name: call.name,
          source: {
            type: 'CallExpression',
            callee: call,
            "arguments": []
          }
        };
      } else if (call.type === 'CallExpression' && call.callee.type === 'MemberExpression' && call.callee.object.type === 'Identifier' && call.callee.object.name === 'async' && call.callee.property.name === 'apply') {
        call.callee = call["arguments"][0];
        call["arguments"] = call["arguments"].slice(1);
        return {
          name: call["arguments"][0].name,
          source: call
        };
      } else if (call.type === 'FunctionExpression') {
        this.signatureIndex[String(this.anonn)] = _.map(call.params, 'name');
        this.anonn += 1;
        return {
          name: String(this.anonn - 1),
          source: {
            type: 'CallExpression',
            callee: call,
            "arguments": []
          }
        };
      } else {
        throw "2789";
      }
    };

    AsyncTranslator.prototype.rewriteWaterfall = function(calls, callback, depth) {
      var call, f, ind, rewrites, test;
      rewrites = [];
      ind = this._indent(depth);
      calls = _.map(calls, this._rewriteWaterfallCall);
      _.each(_.zip(calls.slice(0, -1), calls.slice(1)), (function(_this) {
        return function(arg, j) {
          var call, f, nextCall;
          call = arg[0], nextCall = arg[1];
          f = j === 0 ? [] : {
            type: 'Identifier',
            name: _this.signatureIndex[call.name][0]
          };
          call.source["arguments"] = call.source["arguments"].concat(f);
          return rewrites = rewrites.concat(_this._variableAssignment([_this.signatureIndex[nextCall.name][0]], {
            type: 'AwaitExpression',
            argument: call.source
          }));
        };
      })(this));
      call = _.last(calls);
      f = {
        type: 'Identifier',
        name: this.signatureIndex[call.name][0]
      };
      call.source["arguments"] = call.source["arguments"].concat(f);
      rewrites.push({
        type: 'AwaitExpression',
        argument: call.source
      });
      if (callback && callback.type === 'FunctionExpression' && callback.body.body.length === 1 && callback.body.body[0].type === 'IfStatement') {
        test = callback.body.body[0].test;
        if (test.type === 'Identifier' && test.name === callback.params[0].name) {
          return {
            type: 'TryStatement',
            block: {
              type: 'BlockStatement',
              body: rewrites
            },
            handler: {
              type: 'CatchClause',
              param: {
                type: 'Identifier',
                name: callback.params[0].name
              },
              body: callback.body.body[0].consequent
            },
            finalizer: null
          };
        } else {
          return rewrites;
        }
      } else {
        return rewrites;
      }
    };

    AsyncTranslator.prototype._refactorSerie = function(func) {
      var body;
      this.args.push(_.map(func.params, 'name'));
      body = this._cleanReturns(this.rewriteBlock(func.body.body, 0));
      this.args.pop;
      if (body.length === 1 && body[0].type === 'ReturnStatement') {
        return body[0].argument;
      } else {
        func.body.body = body;
        func.params = [];
        return {
          type: 'AwaitExpression',
          argument: {
            type: 'CallExpression',
            callee: func,
            "arguments": []
          }
        };
      }
    };

    AsyncTranslator.prototype.rewriteSeries = function(functions, endCallback) {
      var assignment, body, list, refactored;
      refactored = _.map(functions, this._refactorSerie);
      if (endCallback) {
        list = {
          type: 'ArrayExpression',
          elements: refactored
        };
        assignment = this._variableAssignment([endCallback.params[1].name], list);
        body = this.rewriteBlock(endCallback.body.body, 0);
        return assignment.concat(body);
      } else {
        return refactored;
      }
    };

    return AsyncTranslator;

  })();

  sourcePath = process.argv[2];

  outputPath = sourcePath.replace(/\.js$/, '.es7');

  asyncifyFile(sourcePath, outputPath);

}).call(this);
